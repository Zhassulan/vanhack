package com.mtelecom.vanhack;

public class MazeSolve1 {

    int GOLDCNT = 15;
    int CELLSIZE = 10;
    int MAXW = 46 * 16 / CELLSIZE;
    int MAXH = 46 * 16 / CELLSIZE;

    class Point {
        int x;
        int y;
    }

    class Node {
        Point p;
        Node next;
    }

    class Queue {
        Node head;
        Node tail;
        int cnt;
    }

    static class CellType {
        static int empty = 0;
        static int wall = 1;
    }

    //информация о клетках лабиринта
    int maze[][] = new int[MAXH][MAXW];
    // кратчайшее растояние от клетки, из которой был запущен алгоритм bfs, до клетки [y][x]
    int dist[][] = new int[MAXH][MAXW];;
    // из какой клетки, при выполнении алгоритма bfs, мы перешли в [y][x], чтобы путь был кратчайшим
    Point prev[][] = new Point[MAXH][MAXW];
    // размеры лабиринта
    int width, height;
    // координаты точки начала и точки конца
    int startx, starty, endx, endy;
    // текущее положение игрока
    Point curpos;
    // количество шагов, которое проделал игрок
    long stepcnt = 0;
    // было ли совершено какое-то передвижение. Используется для того, чтобы определить,
    // нужно ли обводить начальную и конечную точки.
    boolean nomove;

    // Координаты золотых слитков
    Point goldpos[] = new Point[GOLDCNT];
    // Маска, которая показывает, какие слитки были взяти. i-тый бит маски показывает, взят ли i-тый слиток
    int goldpicked;
    // Массивы, используемый для динамического программирования. dp[mask][last] означает следующее:
    // мы уже взяли слитки, соотвествующие маске mask и стоим в точке, где был золотой слиток с номером
    // last ( i-тый бит означает, был ли взят i-тый слиток; 1 - взят, 0 - не взят.
    // dp[mask][last]=-1 означает, что это состояние ещё не было обработано
    int dp[][] = new int[1 << GOLDCNT][GOLDCNT];
    // next[mask][last] - показывает, куда лучше пойти в этом состоянии.
    int next[][] = new int [1<<GOLDCNT][GOLDCNT];
    // golddist[i][j] - кратчайшее расстояние между золотым слитком [i] и золотым слитком [j]
    // (если j<GOLDCNT) или конечной точкой (если j==GOLDCNT)
    int golddist[][] = new int [GOLDCNT][GOLDCNT +1];

    // вспомагательные массивы, благодаря которым можно удобно находить соседние клетки к данной.
    // В данной программе (x+dx[k],y+dy[k]) это соответственно перемещения вниз, вверх, влево, вправо.
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};

    // Очередь это структура данных, в которую можно добавлять элементы только в конец, а брать
    // элементы только из начала
    // устанавливаем для очереди значения по умолчанию
    void initQueue(Queue q) {
        q.head = q.tail = null;
        q.cnt = 0;
    }

    // добавляем в очередь элемент p
    void push(Queue q, Point p) {
        if (q.cnt == 0) {
            q.head = q.tail = NewQueueNode(p);
        } else {
            q.tail.next = NewQueueNode(p);
            q.tail = q.tail.next;
        }
        q.cnt++;
    }

    // достаём из очереди первый элемент
    Point pop(Queue q) {
        Point res = q.head.p;
        Node t = q.head;
        if (q.cnt == 1) {
            q.head = q.tail = null;
        } else {
            q.head = q.head.next;
        }
        q.cnt--;
        return res;
    }

    Node NewQueueNode(Point p) {
        Node n = new Node();
        n.p = p;
        n.next = null;
        return n;
    }

    // проверяем, является ли точка p точкой лабиринта, то есть она находится в прямоугольнике
    // (0,0)->(0,width)->(height,width)->(height,0);
    boolean isGoodPoint(Point p) {
        return ((0 <= p.x) && (p.x < width)) && ((0 <= p.y) && (p.y < height));
    }

    // Алгоритм для поиска кратчайшего пути в графе, в котором каждому ребру приписан вес 1
    // ( в данном случае лабиринт можно представить как граф, в котором каждая клетка - вершина
    // графа, и из каждой вершины есть рёбра в соседнюю веса 1, вес ребра - время перехода)
    // переменная first была введена только для того, чтобы для генерации лабиринта можно было бы
    // использовать тот же алгоритм, что и для поиска. Если first = true, то разрешается непроходимые
    // клетки преобразовывать в проходимые с вероятностью 2/3. Возможность сделать клетку проходимой
    // рассматривается только один раз
    // Коротко алгоритм можно сформулировать так: Пока есть непосещенные достижимые вершины
    // (очередь не пуста), посещаем очередную вершину и добавляем её соседей для обработки, если они
    // ещё не были обработаны, или не находятся в очереди на обработку. Таким образом мы обойдём все
    // вершины графа в порядке возрастания расстояния от начальной
    void bfs(int startx, int starty, boolean first) {
        //создадим очередь вершин и добавим в неё начальную
        //скажем, что расстояние от начальной до начальной вершины равно 0 и предыдущей для начальной нет
        Queue q = new Queue();
        initQueue(q);
        Point cur = new Point();
        Point tmp = new Point();
        cur.x = startx;
        cur.y = starty;
        dist[starty][startx] = 0;
        prev[starty][startx].x = -1;
        prev[starty][startx].y = -1;
        push(q, cur);
        //пока мы не обработаем все вершины
        while (q.cnt != 0) {
            int k;
            //достаём вершину из очереди
            cur = pop(q);
            for (k = 0; k < 4; k++) {
                //перебираем ей соседей и переходим в проходимые клетки, расстояние до которых не определено
                //если first = true, то возможно преобразование клетки лабиринта в проходимую
                tmp.x = cur.x + dx[k];
                tmp.y = cur.y + dy[k];
                if ((isGoodPoint(tmp)) && (dist[tmp.y][tmp.x] == -1) && ((maze[tmp.y][tmp.x] != CellType.wall) || (Math.random() % 3 != 0 && first))) {
                    if (maze[tmp.y][tmp.x] == CellType.wall)
                        maze[tmp.y][tmp.x] = CellType.empty;
                    // говорим, что из cur вершины мы можем придти в tmp,
                    // и расстояние от начальной вершины до вершины tmp на 1 больше
                    dist[tmp.y][tmp.x] = dist[cur.y][cur.x] + 1;
                    prev[tmp.y][tmp.x] = cur;
                    // добавляем вершину в обработку. Достижимые вершины будут добавлены в об
                    push(q, tmp);
                } else if (isGoodPoint(tmp) && (dist[tmp.y][tmp.x] == -1)) {
                    // это условие предназначено для того, чтобы для вершины только один раз выбиралось,
                    // будет ли она проходимой или нет.
                    dist[tmp.y][tmp.x] = -5;
                }
            }
        }
    }


    // функция, реализующая динамическое программирование для поиска кратчайшего пути, если были
    // посещены золотые слитки, соответствующие маске mask (если в i-том бите стоит 1, мы посетили
    // i-тый слиток), и сейчас находимся на месте слитка с номером last
    int fdp(int mask, int last) {
        //Если состояние ещё не было обработано
        if (dp[mask][last] == -1) {
            if (mask == (1 << GOLDCNT) - 1) {
                // если мы посетили все золотые слитки, мы должны идти в конечную точку кратчайшим путём
                dp[mask][last] = golddist[last][GOLDCNT];
            } else {
                int i;
                for (i = 0; i < GOLDCNT; i++) {
                    if ((mask & (1 << i)) == 0) {
                        // если в маске i-тый бит равен 0 (золотой слиток не посещён), то мы пытаемся дойти до
                        // него. (если это первый не посещённый золотой слиток, то мы просто сохраняем результат
                        // перехода в dp[mask][last], иначе мы смотрим, является ли такой путь лучше)
                        if (dp[mask][last] == -1 || dp[mask][last] > fdp(mask | (1 << i), i) + golddist[last][i]) {
                            // мы запоминаем новый лучший результат и в какую клетку выгодно перейти
                            dp[mask][last] = fdp(mask | (1 << i), i) + golddist[last][i];
                            next[mask][last] = i;
                        }
                    }
                }
            }
        }
        return dp[mask][last];
    }

    //Событие, что была нажата некоторая клавиша
    boolean key_press_event() {
        // заводим переменную tmp, чтобы потом сделать один обработчик перемещений
        Point tmp = curpos;
        if (nomove) {
            //если это первое нажатие на клавишу, то говорим, что были нажатия и перерисовываем лабиринт
            nomove = false;
        }
        //реагируем на нажатия соответственно стрелочек вверх, вниз, влево и вправо
        stepcnt = 0;
        goldpicked = 0;
        curpos.x = startx;
        curpos.y = starty;
        int i;
        int j;
        int mind = -1;
        int minidx = 0;
        int curmask;
        int last;
        Point cur = new Point();
        // очищаем информацию о расстоянии от вершины, для которой в прошлый раз был вызван bfs
        for (i = 0; i < height; i++) {
            for (j = 0; j < width; j++) {
                dist[i][j] = -1;
            }
        }
        // находим путь от текущей вершины до каждой достижимой при помощи bfs
        bfs(curpos.x, curpos.y, false);
        // выбираем, к какому золотому слитку нам лучше идти, чтобы получить самый короткий путь
        for (i = 0; i < GOLDCNT; i++) {
            // если i-тый слиток не был поднят и минимальное расстояние не определено или больше
            // чем то, которое мы можем достичь, пойдя к i-тому
            if ((goldpicked & (1 << i)) == 0 && (mind == -1 || mind > dist[goldpos[i].y][goldpos[i].x] + dp[goldpicked | (1 << i)][i])) {
                // говорим, что нам лучше пойти к i-тому слитку
                mind = dist[goldpos[i].y][goldpos[i].x] + dp[goldpicked | (1 << i)][i];
                minidx = i;
            }
        }

        // сохраним в curmask, какие слитки собраны на данный момент; last - куда лучше всего идти
        // при слитках, которые собраны в соответствии с маской curmask; cur - точка, используемая для
        // перебора вершин кратчайшего пути (предыдущее последнее положение)
        curmask = goldpicked;
        last = minidx;
        cur.x = curpos.x;
        cur.y = curpos.y;
        // если ещё не все слитки собраны, то пытаемся куда-то перейти
        while (curmask != (1 << GOLDCNT) - 1) {
            //говорим, что мы посетили слиток с номером last и очищаем массив dist
            curmask |= (1 << last);
            for (i = 0; i < height; i++) {
                for (j = 0; j < width; j++) {
                    dist[i][j] = -1;
                }
            }
            //находим кратчайший путь во все вершины из золотого слитка last
            bfs(goldpos[last].x, goldpos[last].y, false);
            // отображаем путь из точки cur в точку goldpos[last]
            while (true) {
                // рисуем узел пути
                if (prev[cur.y][cur.x].x == -1 && prev[cur.y][cur.x].y == -1) break;
                // если это не последняя вершина (а это можно определить по тому,
                // что у первой вершины нет предыдущей), то мы рисуем линию в предыдущую вершину,
                // иначе мы нарисовали весь путь
                // перемещаемся в предыдущую в кратчайшем пути для текущей вершины клетку.
                cur = prev[cur.y][cur.x];
            }
            // запоминаем новое последнее положение и выбираем новую лучшую вершину, в которую лучше
            // всего пойти.
            cur.x = goldpos[last].x;
            cur.y = goldpos[last].y;
            last = next[curmask][last];

        }
        // по той же схеме отрисовываем кратчайший путь из конечной точки в ту, из которой
        // в последний раз был вызван bfs
        cur.x = endx;
        cur.y = endy;
        while (true) {
            if (prev[cur.y][cur.x].x == -1 && prev[cur.y][cur.x].y == -1) break;
            cur = prev[cur.y][cur.x];
        }
        // если была нажата одна из стрелочек, то мы персчитали в tmp новую точку в соответствии с нажатой
        // клавишей
        if (isGoodPoint(tmp) && maze[tmp.y][tmp.x] != CellType.wall) {
            //то мы увеличиваем количество шагов, открисовываем след, текущую вершину
            stepcnt++;
            curpos = tmp;
            // просматриваем все золотые слитки
            for (i = 0; i < GOLDCNT; i++) {
                if ((goldpicked & (1 << i)) == 0) {
                    // если мы перешли в непосещённый золотой слиток, то мы отмечаем, что мы его посетили
                    if (goldpos[i].x == curpos.x && goldpos[i].y == curpos.y)
                        goldpicked |= (1 << i);
                }
            }
        }
        if (curpos.x == endx && curpos.y == endy && goldpicked == (1 << GOLDCNT) - 1) {
            // Если мы перешли в конечную точку и собрали все золотые слитки, то в терминал выводим
            // за сколько шагов мы его прошли
            System.out.println("Your result:%lld\n" + stepcnt);
        }
        return false;
    }

    int main() {
        int distm = -1;
        // инициализируем генератор случайных чисел текущим временем
        // производим инициализацию gtk и указываем какого размера лабиринт мы будем генерировать
        width = MAXW;
        height = MAXH;
        int i, j, k, gcnt;
        boolean picked;
        // очищаем лабиринт
        for (i = 0; i < height; i++) {
            for (j = 0; j < width; j++) {
                maze[i][j] = CellType.wall;
                dist[i][j] = -1;
                prev[i][j].x = -1;
                prev[i][j].y = -1;
            }
        }
        // случайным образом генерируем начальное положение и говорим, что в нём нет ничего
        startx = 0;
        starty = 0;
        maze[starty][startx] = CellType.empty;
        // при помощи bfs генерируем связанную область лабиринта
        bfs(startx, starty, true);
        // указываем, что сейчас находимся в начальной точке
        curpos.x = startx;
        curpos.y = starty;
        // в качестве конечной точки выберем самую удалённую от начала клетку лабиринта, попутно
        // случайным образом генерируя лабиринт для недостижимых клеток.
        for (i = 0; i < height; i++) {
            for (j = 0; j < width; j++) {
                if (dist[i][j] > distm && prev[i][j].x != -1 && prev[i][j].y != -1) {
                    endx = j;
                    endy = i;
                    distm = dist[endy][endx];
                } else if (dist[i][j] == -1) {
                    maze[i][j] = (int) Math.random() % 2;
                }
            }
        }
        //создадим на поле GOLDCNT золотых слитков случайным образом
        for (gcnt = 0; gcnt < GOLDCNT; gcnt++) {
            // утверждаем, что не выбрали никакого слитка
            picked = false;
            for (i = 0; i < height && !picked; i++) {
                for (j = 0; j < width && !picked; j++) {
                    // в начальном положении, конечном положении, недостижимых клетках лабиринта
                    // и стенах золотых слитков быть не может
                    // в остальных случаях мы с вероятностью 1 10000 будем выбирать клетку
                    // в качестве той, которая содержит слиток
                    if ((i == starty && j == startx) || (i == endy && j == endx))
                        continue;
                    if (maze[i][j] == CellType.empty && dist[i][j] > 0 && Math.random() % 10000 == 0) {
                        goldpos[gcnt].x = j;
                        goldpos[gcnt].y = i;
                        // утверждаем, что слиток выбран
                        picked = true;
                    }
                }
            }
            // если мы так и не выбрали клетку для слитка, то мы попробуем ещё раз
            if (!picked) gcnt--;
        }
        // вычислим расстояние от каждой клетки с золотом до каждой клетки с золотом и до конечной
        for (i = 0; i < GOLDCNT; i++) {
            // очищаем массив расстояний и запускаем bfs из клетки с новым золотым слитком
            for (j = 0; j < height; j++) {
                for (k = 0; k < width; k++) {
                    dist[j][k] = -1;
                }
            }
            bfs(goldpos[i].x, goldpos[i].y, false);
            // после вызова расстояния сохранятся в массиве dist и поэтому их нужно только достать
            for (j = 0; j < GOLDCNT; j++) {
                golddist[i][j] = dist[goldpos[j].y][goldpos[j].x];
            }
            golddist[i][GOLDCNT] = dist[endy][endx];
        }
        // говорим, что все состояния динамики являются необработанными
        for (i = 0; i < (1 << GOLDCNT); i++)
            for (j = 0; j < GOLDCNT; j++)
                dp[i][j] = -1;
        // запускаем алгоритм динамического программирования для случаев, когда мы посетили
        // i-тую вершину и находимся сейчас в ней. Эти вызовы переберут все возможные состояния
        for (i = 0; i < GOLDCNT; i++)
            fdp((1 << i), i);
        //очистим матрицу расстояний и вызовим bfs от начальной вершины
        for (j = 0; j < height; j++) {
            for (k = 0; k < width; k++) {
                dist[j][k] = -1;
            }
        }
        bfs(startx, starty, false);
        // выясним, какова длина самого короткого пути, который является решением задачи
        distm = -1;
        for (i = 0; i < GOLDCNT; i++) {
            // очевидно, что короткий путь будет состоять из перемещения к одному из слитков,
            // а потом от него к остальным, поэтому он может быть вычислен как
            // dist[goldpos[i].y][goldpos[i].x]+dp[1<<i][i]
            if (distm == -1 || distm > dist[goldpos[i].y][goldpos[i].x] + dp[1 << i][i]) {
                distm = dist[goldpos[i].y][goldpos[i].x] + dp[1 << i][i];
            }
        }
        // если золотых слитков не было, то тогда кратчайшее расстояние
        // это путь из начальной точки в конечную
        if (GOLDCNT == 0) {
            distm = dist[endy][endx];
        }

        System.out.println("Best result:%d\n" + distm);

        // создаём окно и подключаем обработчики событий, говорим, что не было ещё ни одного нажатия
        // на клавишу клавиатуры. После этого показываем окно, заполняем палитру и запускаем программу
        nomove = true;
        return 0;
    }
}
